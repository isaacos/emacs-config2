* keybinding modes
#+BEGIN_SRC emacs-lisp
                (use-package which-key
                  :init (which-key-mode)
                  (which-key-enable-god-mode-support)
                  :diminish which-key-mode
                  :config
                  (setq which-key-idle-delay 0.3))

                ;;(global-unset-key "\C-d")
                (global-set-key (kbd "C-x m") #'eshell)
                ;; allows user to paste inside minibuffer
                ;;(define-key minibuffer-local-map (kbd "C-p") 'yank)

                (defun match-paren (arg)
                  "Go to the matching paren if on a paren; otherwise insert %."
                  (interactive "p")
                  (cond ((looking-at "\\s(") (forward-list 1) (backward-char 1))
                        ((looking-at "\\s)") (forward-char 1) (backward-list 1))
                        (t (self-insert-command (or arg 1)))))

                (use-package avy
                  :init
                  (setq avy-all-windows 'all-frames)
                  (setq avy-style 'at)
                  (setq avy-highlight-first t)
                  (setq avy-styles-alist '((avy-goto-char . at)
                     (avy-goto-line . at-full)
                     (avy-goto-end-of-line . post)))
                  (setq avy-keys '(?a ?s ?d ?g ?h ?j ?k ?l ?\;))
                  :config
                  (global-set-key (kbd "C-c j m") #'avy-pop-mark))

                (use-package anzu
                  :ensure t
                  :config
                  (global-anzu-mode +1)
                  (custom-set-variables
                    '(anzu-mode-lighter "")
                    '(anzu-replace-to-string-separator " => ")))

                (define-key isearch-mode-map [remap isearch-query-replace]  #'anzu-isearch-query-replace)
                (define-key isearch-mode-map [remap isearch-query-replace-regexp] #'anzu-isearch-query-replace-regexp)
  (global-set-key (kbd "H-r") 'anzu-query-replace-at-cursor)

    (use-package ace-window
      :ensure t
      :config
      (global-set-key (kbd "C-x o") 'ace-window)
      ;;customize to make face more visible
      (custom-set-faces
       '(aw-leading-char-face
         ((t (:foreground "#1f2430" :background "#f28779" :height 3.0)))))

      ;; (defface aw-leading-char-face
      ;; '((((class color)) (:foreground "white"))
      ;;   (((background dark)) (:foreground "#e52b50"))
      ;;   (((background light)) (:foreground "gray0"))
      ;;   (t (:foreground "gray100" :underline nil)))
      ;; "Face for each window's leading char.")
      (setq aw-keys '(?s ?d ?f ?g ?h ?j ?k ?l)))

    (use-package puni
    ;;:defer t
    :config
    (global-set-key (kbd "C->") #'puni-slurp-forward)
    (global-set-key (kbd "C-<") #'puni-barf-forward))

  (use-package hydra
    :ensure t)

  (defun kmacro-toggle-start-end ()
    "Starts kmacro unless one is already in progress than it ends it"
    (interactive)
    (if defining-kbd-macro
        (kmacro-end-macro 1)
      (kmacro-start-macro 0)))


    (org-babel-load-file (expand-file-name "~/.emacs.d/my-god-mode-config.el"))

          (defun run-arg-in-god-mode (arg key-arg)
            (interactive "p")

            (if god-local-mode
              (funcall (key-binding (eval key-arg)))
              (self-insert-command (or arg 1))))

              ;; (define-minor-mode fast-nav-mode
              ;;     "Minor mode to rapidly move over large sections of code"
              ;;     :lighter "Fast-nav"
              ;;     :keymap (let ((map (make-keymap)))
              ;;               (define-key map (kbd "j") 'forward-sexp)
              ;;               (define-key map (kbd "t") 'hs-toggle-hiding)
              ;;               (define-key map (kbd "T") 'hs-hide-all)
              ;;               (define-key map (kbd "k") 'backward-sexp)
              ;;               (define-key map (kbd "d") 'down-list)
              ;;               (define-key map (kbd "u") 'up-list)
              ;;               (define-key map (kbd "m") 'consult-mark)
              ;;               (define-key map (kbd "f") 'forward-paragraph)
              ;;               (define-key map (kbd "b") 'backward-paragraph)
              ;;               (define-key map (kbd "n") 'fast-nav-mode)
              ;;               map))

                (use-package key-chord
                  :ensure t
                  :init (key-chord-mode 1)
                  :config
                  (key-chord-define-global "ii" 'god-mode-all)
                  (key-chord-define-global "xs" 'save-buffer)
                  (key-chord-define-global "jl" 'avy-goto-line)
                  (key-chord-define-global "jw" 'ace-window)
                  (key-chord-define-global "je" 'avy-goto-end-of-line)
                  (key-chord-define-global "jk" 'avy-goto-char)
                  (key-chord-define god-local-mode-map "mm" 'execute-extended-command-for-buffer)
                  (key-chord-define god-local-mode-map "xx" 'execute-extended-command))
#+END_SRC

* Defaults
#+BEGIN_SRC emacs-lisp
  (use-package hideshow)

  (repeat-mode)

  (setq-default isearch-yank-on-move t)
  (setq-default set-mark-command-repeat-pop t)

  (use-package zop-to-char
    :config
    (global-set-key (kbd "C-z") #'zop-up-to-char))

(use-package winner
  :config
  (winner-mode 1)
  :bind (("C-c w /" . winner-undo)
         ("C-c w _" . winner-redo)))
  
  (use-package super-save
  :ensure t
  :config
  (super-save-mode +1))
#+END_SRC

* Dired
#+BEGIN_SRC emacs-lisp
 (use-package dirvish
   :init
   (dirvish-override-dired-mode)
   :custom
   (dirvish-quick-access-entries ; It's a custom option, `setq' won't work
    '(("h" "~/"                          "Home")
      ("d" "~/Downloads/"                "Downloads")))
   :config
   ;; (dirvish-peek-mode) ; Preview files in minibuffer
   ;; (dirvish-side-follow-mode) ; similar to `treemacs-follow-mode'
   (setq dirvish-mode-line-format
         '(:left (sort symlink) :right (omit yank index)))
   (setq dirvish-attributes
         '(all-the-icons file-time file-size collapse subtree-state vc-state git-msg))
   (setq delete-by-moving-to-trash t)
   (setq dired-listing-switches
         "-l --almost-all --human-readable --group-directories-first --no-group")
   :bind ; Bind `dirvish|dirvish-side|dirvish-dwim' as you see fit
   (("C-c f" . dirvish-fd)
    ("C-c d d" . dirvish-dwm)
    ("C-c d t" . dirvish-side)
    :map dirvish-mode-map ; Dirvish inherits `dired-mode-map'
    ("a"   . dirvish-quick-access)
    ("f"   . dirvish-file-info-menu)
    ("y"   . dirvish-yank-menu)
    ("N"   . dirvish-narrow)
    ("^"   . dirvish-history-last)
    ("h"   . dirvish-history-jump) ; remapped `describe-mode'
    ("s"   . dirvish-quicksort)    ; remapped `dired-sort-toggle-or-edit'
    ("v"   . dirvish-vc-menu)      ; remapped `dired-view-file'
    ("TAB" . dirvish-subtree-toggle)
    ("M-f" . dirvish-history-go-forward)
    ("M-b" . dirvish-history-go-backward)
    ("M-l" . dirvish-ls-switches-menu)
    ("M-m" . dirvish-mark-menu)
    ("M-t" . dirvish-layout-toggle)
    ("M-s" . dirvish-setup-menu)
    ("M-e" . dirvish-emerge-menu)
    ("M-j" . dirvish-fd-jump)))
#+END_SRC
* appearance
#+BEGIN_SRC emacs-lisp
       (menu-bar-mode -1) 

      (setq doom-rouge-brighter-comments t)
      (setq doom-rouge-comment-bg t)
      (load-theme 'doom-rouge :no-confirm)

      (custom-set-faces
      '(org-level-1 ((t (:inherit outline-1 :height 1.5))))
      '(org-level-2 ((t (:inherit outline-2 :height 1.3))))
      '(org-level-3 ((t (:inherit outline-3 :height 1.2))))
      '(org-level-4 ((t (:inherit outline-4 :height 1.1))))
      '(org-level-5 ((t (:inherit outline-5 :height 1.05)))))

         (use-package all-the-icons
           :ensure t)

          (use-package doom-modeline
            :ensure t
            :init
            :hook (after-init . doom-modeline-mode)
            :config
            ;;(setq doom-modeline-hud t)
            (setq doom-modeline-minor-modes t)
            (setq doom-modeline-buffer-encoding nil))

         (use-package rainbow-delimiters
          :ensure t
          :defer t
          :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

* projects
#+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t)
#+END_SRC

* Git
#+BEGIN_SRC emacs-lisp
        (use-package magit
          :ensure t
          :defer t
          :commands (magit-status magit-get-current-branch)
          :custom
          (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

        (use-package diff-hl
          :ensure t
          :init
          (global-diff-hl-mode))
#+END_SRC

* emacs completion frameworks
#+BEGIN_SRC emacs-lisp
    (defun dw/minibuffer-backward-kill (arg)
      "When minibuffer is completing a file name delete up to parent
    folder, otherwise delete a word"
      (interactive "p")
      (if minibuffer-completing-file-name
          ;; Borrowed from https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608
          (if (string-match-p "./" (minibuffer-contents))
              (zap-up-to-char (- arg) ?/)
            (delete-minibuffer-contents))
        (delete-backward-char arg)))

  (defvar vertico-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "j") #'vertico-next)
      (define-key map (kbd "k") #'vertico-previous)
      map))

  (dolist (cmd '(vertico-next vertico-previous))
    (put cmd 'repeat-map 'vertico-repeat-map))

    (use-package vertico
      :ensure t
      :bind (:map vertico-map
             ("C-j" . vertico-next)
             ("C-k" . vertico-previous)
             ("C-f" . vertico-exit)
             :map minibuffer-local-map
             ("DEL" . dw/minibuffer-backward-kill))
      :custom
      (vertico-cycle t)
      :init
      (vertico-mode))

    (use-package orderless
      :ensure t
      :custom
      (completion-styles '(orderless basic))
      (completion-category-overrides '((file (styles basic partial-completion)))))

    (defun dw/get-project-root ()
      (when (fboundp 'projectile-project-root)
        (projectile-project-root)))

    (setq completion-ignore-case  t)

    (setq read-file-name-completion-ignore-case t
          read-buffer-completion-ignore-case t
          completion-ignore-case t)

    (use-package marginalia
      :ensure t
      :config
      (marginalia-mode))

  
(use-package embark
  :ensure t
  :bind
  (("C-," . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)
  ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
  ;; strategy, if you want to see the documentation from multiple providers.
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))

#+END_SRC

* searching
#+BEGIN_SRC emacs-lisp
    (use-package consult
      :bind (("C-M-l" . consult-imenu)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch        ("C-M-j" . persp-switch-to-buffer*)
         :map minibuffer-local-map
         ("C-r" . consult-history))
      :custom
      (consult-project-root-function #'dw/get-project-root)
      (completion-in-region-function #'consult-completion-in-region))

    (define-key isearch-mode-map (kbd "M-RET")
      #'isearch-exit-other-end)

    (defun isearch-exit-other-end ()
      "Exit isearch, at the opposite end of the string.
  from https://endlessparentheses.com/leave-the-cursor-at-start-of-match-after-isearch.html"
      (interactive)
      (isearch-exit)
      (goto-char isearch-other-end))

#+END_SRC

* notes
#+BEGIN_SRC emacs-lisp
  (use-package denote
    :config
    (global-unset-key (kbd "C-x C-n"))
    (global-set-key (kbd "C-x C-n C-s") #'consult-notes)
    (global-set-key (kbd "C-x C-n C-m") #'denote)
    (setq denote-known-keywords '("code" "history" "current-events"))
    (setq denote-directory (expand-file-name "/home/isaac/denote/"))
    (setq denote-file-type nil))

  ;;(add-hook 'dired-mode-hook #'denote-dired-mode)

  (use-package consult-notes
    :ensure t
    ;;:straight ( :type git :host github :repo "mclear-tools/consult-notes")
    :commands (consult-notes consult-notes-search-in-all-notes)
    :config
    (setq consult-notes-file-dir-sources '(("Name"  ?n  "/home/isaac/denote/")))
    ;;(global-unset-key (kbd "C-x C-n") nil)


    ;; Set org-roam integration OR denote integration, e.g.:
    (when (locate-library "denote")
      (consult-notes-denote-mode)))



#+END_SRC

* Common Lisp
#+BEGIN_SRC emacs-lisp
  (use-package sly)
  ;; (use-package sly
  ;; :straight (:type git :host github :repo "joaotavora/sly")
  ;; :commands (sly sly-connect))

  ;; (setq sly-lisp-implementations '((sbcl ("sbcl" "--core"
  ;;     "sbcl.core-for-sly"))))
#+END_SRC

* Clojure
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :defer t
  :ensure t
  :mode (("\\.clj\\'" . clojure-mode)
         ("\\.edn\\'" . clojure-mode))
  :init
  ;; (add-hook 'clojure-mode-hook #'yas-minor-mode)
  ;; (add-hook 'clojure-mode-hook #'subword-mode)
  ;; (add-hook 'clojure-mode-hook #'eldoc-mode)
  (add-hook 'clojure-mode-hook #'idle-highlight-mode))

(use-package cider
;;   :straight (:type git :host github :repo "clojure-emacs/cider")
  :ensure t
  :defer t
  :init (add-hook 'cider-mode-hook #'clj-refactor-mode)
  :diminish subword-mode
  :config
    (setq nrepl-log-messages t
        cider-repl-display-in-current-window t
        cider-repl-use-clojure-font-lock t
        cider-prompt-save-file-on-load 'always-save
        cider-font-lock-dynamically '(macro core function var)
        nrepl-hide-special-buffers t
        cider-overlays-use-font-lock t)
  (cider-repl-toggle-pretty-printing))
#+END_SRC

* Javascript/Typescript
- TODO look into auto importing for JS
  - [[eww: https://github.com/KarimAziev/js-imports][JS imports]]
  - Switching to lsp-mode with lsp-completion-enable-additional-text-edit
  - adding a jsconfig to the project
- TODO linting issue
  - [[eww:http://mitchgordon.me/software/2021/06/28/why-vscode-eslint-fast.html][flycheck-mode article]]
    
#+BEGIN_SRC emacs-lisp
    (use-package js2-mode
      :ensure t)

  (use-package prettier-js
    :ensure t
    :after (rjsx-mode)
    :hook (rjxs . prettier-js-mode))

    (add-hook 'js-mode-hook 'prettier-js-mode)
    (add-hook 'web-mode-hook 'prettier-js-mode)
  (add-hook 'rjxs-mode 'prettier-js-mode)

    ;; (add-to-list 'auto-mode-alist '("\\.js\\'" . js-mode))
    ;; (add-to-list 'auto-mode-alist '("\\.jsx\\'" . js-mode))
    ;; (add-hook 'js-mode-hook 'js2-minor-mode)

    (use-package js-mode
      :init
      (define-key js-mode-map (kbd "C-k") #'xah-backward-left-bracket)
      (define-key js-mode-map (kbd "C-j") #'forward-left-bracket))

    (use-package rjsx-mode
      :ensure t)
  
  (add-to-list 'auto-mode-alist '("\\.js\\'" . rjsx-mode))

  ;; (defun setup-tide-mode ()
  ;;   "Sets up tide"
  ;;   (interactive)
  ;;   (tide-setup)
  ;;   (flycheck-mode +1)
  ;;   (tide-hl-identifier-mode +1))

  ;; (use-package tide
  ;;   :ensure t
  ;;   :after (rjsx-mode corfu-mode flycheck)
  ;;   :hook (rjsx-mode . setup-tide-mode))

  ;;   (with-eval-after-load 'js-mode
  ;;     '(define-key js-mode-map (kbd "C-j") #'forward-left-bracket))
  ;;            (setq completion-category-defaults nil))

#+END_SRC

* LSP
#+BEGIN_SRC emacs-lisp
            (use-package eglot
                  :ensure t
                  :commands (eglot eglot-ensure)
                  :config
                  (define-key eglot-mode-map (kbd "M-.") #'xref-find-definitions)
                  :hook ((clojure-mode . eglot-ensure)
                         ;;(js-mode . eglot-ensure)
                         ))
            ;; Option 1: Specify explicitly to use Orderless for Eglot

              (setq completion-category-overrides '((eglot (styles orderless))))

              (use-package consult-eglot
                :ensure t)

          (global-tree-sitter-mode)
    (add-hook 'js-mode-hook #'tree-sitter-hl-mode)

      (use-package lsp-mode
        :commands lsp
        :hook ((
                web-mode
                rjsx-mode
                ;; javascript-ts-mode
                ;; typescript-ts-mode
                ;; jsx-ts-mode
                ;; tsx-ts-mode
                )
               . lsp-deferred)
        (lsp-completion-mode . my/lsp-mode-setup-completion)
        (lsp-mode . lsp-enable-which-key-integration)
        :config
        (setq lsp-idle-delay 0.1
              lsp-log-io nil
              lsp-completion-provider :none
              lsp-headerline-breadcrumb-enable nil
              lsp-solargraph-use-bundler 't)
        :init
        (defun my/orderless-dispatch-flex-first (_pattern index _total)
          (and (eq index 0) 'orderless-flex))

        (defun my/lsp-mode-setup-completion ()
          (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
                '(orderless)))
        
  ;;specific for JavaScript and requires VSCode
  (setq lsp-eslint-server-command 
     '("node" 
       "/home/isaac/.vscode-oss/extensions/dbaeumer.vscode-eslint-2.4.0/server/out/eslintServer.js" 
       "--stdio"))

        ;; Optionally configure the first word as flex filtered.
        (add-hook 'orderless-style-dispatchers #'my/orderless-dispatch-flex-first nil 'local)

        ;; Optionally configure the cape-capf-buster.
        (setq-local completion-at-point-functions (list (cape-capf-buster #'lsp-completion-at-point)))
        (setq lsp-keymap-prefix "C-l"))


        (add-hook 'lua-mode-hook #'tree-sitter-hl-mode)
        (add-hook 'sh-mode-hook #'tree-sitter-hl-mode)

#+END_SRC
* autocomplete
#+BEGIN_SRC emacs-lisp

  (use-package cape
    :init
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    ;; (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file))

  (defvar corfu-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "j") #'corfu-next)
      (define-key map (kbd "k") #'corfu-previous)
      map))

  (dolist (cmd '(corfu-next corfu-previous))
    (put cmd 'repeat-map 'corfu-repeat-map))

  (use-package corfu
    ;; Optional customizations
     :custom
     (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
     (corfu-auto t)                 ;; Enable auto completion
     (corfu-auto-delay 0)
     (corfu-auto-prefix 1)
     (corfu-separator ?\s)          ;; Orderless field separator
     :init
     (global-corfu-mode)
     :bind
     (:map corfu-map ("C-j" . corfu-next)))

  (use-package emacs
    :init
    ;; TAB cycle if there are only few candidates

  
    (setq completion-cycle-threshold 1)
            ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
            ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
            ;; (setq read-extended-command-predicate
            ;;       #'command-completion-default-include-p)
            ;; Enable indentation+completion using the TAB key.
            ;; `completion-at-point' is often bound to M-TAB.
            (setq tab-always-indent 'complete))


#+END_SRC

* org
#+BEGIN_SRC emacs-lisp

  (setq ispell-program-name "/usr/bin/hunspell")

  (setq ispell-hunspell-dict-paths-alist

  '(("en_US" "~/Library/Spelling/en_US.aff")))

  (setq ispell-local-dictionary "en_US")

  (setq ispell-local-dictionary-alist

  ;; Please note the list `("-d" "en_US")` contains ACTUAL parameters passed to hunspell

  ;; You could use `("-d" "en_US,en_US-med")` to check with multiple dictionaries

  '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

      (use-package org-bullets
      :after org
      :hook (org-mode . org-bullets-mode)
      :custom
      (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

    ;; renames buffer when the name starts with title
    (defun org+-buffer-name-to-title ()
      "Rename buffer to value of #+title:."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward "^[[:space:]]*#\\+TITLE:[[:space:]]*\\(.*?\\)[[:space:]]*$" nil t)
          (rename-buffer (match-string 1)))))

    (add-hook 'org-mode-hook #'org+-buffer-name-to-title)
  (setq cape-dict-file "~/Library/Spelling/en_US.dic")
        ;; Turn on indentation and auto-fill mode for Org files
      (defun dw/org-mode-setup ()
        (org-bullets-mode)
        (org-indent-mode)
      ;;  (variable-pitch-mode 1)
        (auto-fill-mode 0)
        (visual-line-mode 1)
        ;; (setq evil-auto-indent nil)
        ;; (company-ispell)

        (add-to-list 'completion-at-point-functions #'cape-ispell)
        (add-to-list 'completion-at-point-functions #'cape-dict)
        (org+-buffer-name-to-title)
        )

      (use-package org
        :defer t
        :hook (org-mode . dw/org-mode-setup)
        :config

        (unbind-key "C-," org-mode-map)
        (setq org-agenda-start-with-log-mode t)
        (setq org-log-done `time)
        (setq org-log-into-drawer t))
#+END_SRC

* PDF
#+BEGIN_SRC emacs-lisp
    (setq doc-view-continuous t)

      (add-hook 'doc-view-mode-hook (lambda ()
                                      (local-set-key (kbd "C-j") 'doc-view-next-line-or-next-page) (local-set-key (kbd
      "C-k") 'doc-view-previous-line-or-previous-page)))


  ;; (add-hook 'doc-view-mode-hook

  
  ;;   (lambda ()
  ;;     (message "you are now in doc-view mode")
  ;;    (define-key evil-normal-state-local-map (kbd "k") 'doc-view-previous-line-or-previous-page)
  ;;    (define-key evil-normal-state-local-map (kbd "j") 'doc-view-next-line-or-next-page)))


  (use-package pdf-tools
    :defer t)

  (add-hook 'pdf-view-mode-hook
            (lambda ()
              (local-set-key (kbd "j") 'pdf-view-scroll-up-or-next-page)
              (local-set-key (kbd "k") 'pdf-view-scroll-down-or-previous-page)))

    ;; (use-package pdf-tools
    ;;   :defer t)

    ;; (add-hook 'pdf-view-mode-hook
    ;;           (lambda ()
    ;;             (local-set-key (kbd "n") 'pdf-view-scroll-up-or-next-page)
    ;;             (local-set-key (kbd "p") 'pdf-view-scroll-down-or-previous-page)))
#+END_SRC

* EWW
#+BEGIN_SRC emacs-lisp
  (use-package eww
    :config
    (define-key eww-mode-map (kbd "C-j") #'forward-paragraph)
    (define-key eww-mode-map (kbd "C-k") #'backward-paragraph))
#+END_SRC
